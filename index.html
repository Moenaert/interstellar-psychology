<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Psychedelic Mandelbrot Zoom</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: black;
        }
        #mandelbrot {
            display: block;
            filter: blur(1px) brightness(1.2) contrast(1.3); /* Psychedelic glow */
        }
        #matrix {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none; /* Prevent interference with Mandelbrot canvas */
        }
    </style>
</head>
<body>
    <canvas id="mandelbrot"></canvas>
    <canvas id="matrix"></canvas>
    <script>
        // Mandelbrot Canvas
        const mandelbrotCanvas = document.getElementById('mandelbrot');
        const mandelbrotCtx = mandelbrotCanvas.getContext('2d');

        // Matrix Canvas
        const matrixCanvas = document.getElementById('matrix');
        const matrixCtx = matrixCanvas.getContext('2d');

        // Set canvas sizes
        function resizeCanvases() {
            mandelbrotCanvas.width = window.innerWidth;
            mandelbrotCanvas.height = window.innerHeight;
            matrixCanvas.width = window.innerWidth;
            matrixCanvas.height = window.innerHeight;
        }
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);

        // Mandelbrot parameters
        let zoom = 1;
        let centerX = -0.75; // Baby Mandelbrot region
        let centerY = 0.1;
        const maxIter = 150;
        let zoomSpeed = 0.85;
        let isZooming = false;
        let targetX, targetY;
        let time = 0;

        function drawMandelbrot() {
            const width = mandelbrotCanvas.width;
            const height = mandelbrotCanvas.height;
            const imageData = mandelbrotCtx.createImageData(width, height);
            const data = imageData.data;

            const scale = 4 / (zoom * Math.min(width, height));

            for (let px = 0; px < width; px++) {
                for (let py = 0; py < height; py++) {
                    const x0 = centerX + (px - width / 2) * scale;
                    const y0 = centerY + (py - height / 2) * scale;
                    let x = 0;
                    let y = 0;
                    let iter = 0;

                    while (x * x + y * y <= 4 && iter < maxIter) {
                        const xtemp = x * x - y * y + x0;
                        y = 2 * x * y + y0;
                        x = xtemp;
                        iter++;
                    }

                    const index = (px + py * width) * 4;
                    if (iter === maxIter) {
                        data[index] = 0;
                        data[index + 1] = 0;
                        data[index + 2] = 0;
                    } else {
                        // Psychedelic palette: pink, green, blue, purple
                        const hue = (iter / maxIter * 360 + time) % 360;
                        let r, g, b;
                        if (hue < 90) { // Pink to purple
                            r = 255;
                            g = Math.sin(hue / 90 * Math.PI) * 105;
                            b = 255 - Math.sin(hue / 90 * Math.PI) * 100;
                        } else if (hue < 180) { // Purple to blue
                            r = 255 - Math.sin((hue - 90) / 90 * Math.PI) * 150;
                            g = Math.sin((hue - 90) / 90 * Math.PI) * 100;
                            b = 255;
                        } else if (hue < 270) { // Blue to green
                            r = Math.sin((hue - 180) / 90 * Math.PI) * 100;
                            g = 255;
                            b = 255 - Math.sin((hue - 180) / 90 * Math.PI) * 200;
                        } else { // Green to pink
                            r = 255 - Math.sin((hue - 270) / 90 * Math.PI) * 100;
                            g = 255 - Math.sin((hue - 270) / 90 * Math.PI) * 150;
                            b = Math.sin((hue - 270) / 90 * Math.PI) * 150;
                        }
                        data[index] = r;
                        data[index + 1] = g;
                        data[index + 2] = b;
                    }
                    data[index + 3] = 255;
                }
            }

            mandelbrotCtx.putImageData(imageData, 0, 0);
            time += 0.5; // Increment for color cycling
        }

        // Matrix sentence animation
        const sentence = "Exit the Matrix!";
        const fontSize = 40;
        let charIndex = 0;
        let lastUpdate = 0;
        const typingSpeed = 100; // Milliseconds per character

        function drawMatrix() {
            matrixCtx.clearRect(0, 0, matrixCanvas.width, matrixCanvas.height);
            matrixCtx.font = `${fontSize}px monospace`;
            matrixCtx.fillStyle = '#00ff00'; // Green Matrix text
            matrixCtx.textAlign = 'center';
            const centerX = matrixCanvas.width / 2;
            const centerY = matrixCanvas.height / 2;

            // Calculate the substring to display
            const currentTime = performance.now();
            if (currentTime - lastUpdate > typingSpeed) {
                charIndex = (charIndex + 1) % (sentence.length + 5); // +5 for pause at end
                lastUpdate = currentTime;
            }
            const displayText = charIndex <= sentence.length ? sentence.slice(0, charIndex) : sentence;

            matrixCtx.fillText(displayText, centerX, centerY);
        }

        // Combined animation loop
        function animate() {
            if (isZooming) {
                zoom *= 1 / zoomSpeed;
                const scale = 4 / (zoom * Math.min(mandelbrotCanvas.width, mandelbrotCanvas.height));
                centerX += (targetX - mandelbrotCanvas.width / 2) * scale * (1 - zoomSpeed);
                centerY += (targetY - mandelbrotCanvas.height / 2) * scale * (1 - zoomSpeed);
                drawMandelbrot();
            }
            drawMatrix();
            requestAnimationFrame(animate);
        }

        // Mouse down to start zooming
        mandelbrotCanvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // Left click
                isZooming = true;
                const rect = mandelbrotCanvas.getBoundingClientRect();
                targetX = e.clientX - rect.left;
                targetY = e.clientY - rect.top;
            }
        });

        // Mouse up to stop zooming
        mandelbrotCanvas.addEventListener('mouseup', () => {
            isZooming = false;
        });

        // Right-click to reset
        mandelbrotCanvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            isZooming = false;
            zoom = 1;
            centerX = -0.75; // Reset to baby Mandelbrot region
            centerY = 0.1;
            time = 0;
            charIndex = 0; // Reset text animation
            lastUpdate = performance.now();
            drawMandelbrot();
        });

        // Initial draw and start animation
        drawMandelbrot();
        animate();
    </script>
</body>
</html>